#!/usr/bin/env python3

from subprocess import Popen
import itertools
import os
import re
import sys

CMD_DOCKER = ["docker", "exec", "-it", "dc-pointy-app"]
CMD_NOSE = ["python", "-m", "nose", "--rednose", "--stop", "--logging-level=INFO"]
CMD_NOSE = ["python", "-m", "nose", "--rednose", "--logging-level=INFO"]
RE_ONTEST = re.compile(r".*#\s*ontest\s*open\s(?P<url>https?://.+?)[#,\s$]")

def cmd_open(argument):
    command = "open '%s'" % argument
    print(command)
    proc = Popen(command, shell=True)
    return proc.wait()

def cmd(argument):
    command = argument
    print(command)
    proc = Popen(command, shell=True)
    return proc.wait()

DEPLOY_SANDBOX = (cmd, "xterm -e p.deploy & ")
RUN_CONSOLE = [cmd, "p.console '%s' | ccze -A -o nolookups"]
TRIGGERS = {
    re.compile(r'terminal-'): [RUN_CONSOLE],
#     re.compile(r'dynamic_bids'): [RUN_CONSOLE],
    re.compile(r'email'): [DEPLOY_SANDBOX],
}


def filter_arguments(arguments):
    """
    Yields only Python files or directory that exist.
    When source code, looks for ontest commands
    """
    for path in arguments:

        if os.path.isdir(path):
            yield path

        elif os.path.isfile(path):

            for regex, commands in TRIGGERS.items():
                if regex.search(path):
                    for command in commands:
                        function, arguments = command[0], command[1:]
                        for pos, arg in enumerate(arguments):
                            if "%s" in arg:
                                print(arg)
                                arguments[pos] = arg % path
                        function(*arguments)
            extension = path.split(".")[-1]
            if "py" in extension:
                yield path


def get_test_paths(path):
    """
    Returns the corresponding filename for the testsuite.
    If the given filename is a test file it returns original filename.
    """
    path = os.path.normpath(path)
    if path.startswith("test/") or path.startswith("tests/"):
        yield path
    else:
        levels = path.split(os.path.sep)
        prefixes = itertools.product(*[("test_", "")]*len(levels))
        for prefix in prefixes:
            new_levels = ["".join((p, l)) for p, l in zip(prefix, levels)]
            for root in ("tests/", "test/"):
                test_path = root + os.path.sep.join(new_levels)
                if os.path.exists(test_path):
                    yield test_path


def nosetest(paths):
    """
    Runs nosetest on the given path.
    Returns return code of th ecommand.
    """
    paths = ["'%s'" % path for path in paths]
    command = CMD_DOCKER + CMD_NOSE + paths
    command = " ".join(command)
    command += "|awk '{sub(\" line \", \":\")}; /./'"
    print(command)
    proc = Popen(command, shell=True)
    return proc.wait()


if __name__ == "__main__":
    arguments = sys.argv[1:]
    for arg in filter_arguments(arguments):
        paths = list(get_test_paths(arg))
        if paths:
            print("=" * 80)
            print("\n".join(paths))
            nosetest(paths)
